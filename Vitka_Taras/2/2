
## Львівський Національний Університет Природокористування  
## Кафедра Інформаційних систем та Технологій

### Звіт про виконання лабораторної роботи №2
# "Структурні патерни проектування"

| Виконав: студент групи КН-31 Вітка Тарас |  
|--------------------------------------------|  
| Перевірив: Татомир Андрій                  |

Мета: Познайомитися з групою структурних патернів.

### Хід роботи

1. Дати теоретичний опис структурних патернів.
2. Дати теоретичний опис вибраного патерну.
3. Навести приклад коду, який реалізовує даний патерн.
4. Скласти його UML-діаграму.

### Теоретичний опис структурної групи шаблонів

Структурні патерни проектування фокусуються на способах організації класів і об'єктів для формування складних структур, що складаються з багатьох частин. Вони допомагають розробникам створювати гнучкі та ефективні програми, визначаючи, як класи і об'єкти можуть взаємодіяти між собою.

Основні структурні патерни включають:

Адаптер (Adapter): Дозволяє об'єктам з несумісними інтерфейсами працювати разом.
Декоратор (Decorator): Додає нову поведінку до об'єктів, не змінюючи їхнього класу.
Фасад (Facade): Спрощує інтерфейс для складної підсистеми.
Композит (Composite): Дозволяє об'єктам формувати ієрархії, де окремі об'єкти і складені об'єкти можуть бути оброблені однаково.

### Патерн "Адаптер"

Адаптер — це структурний патерн проектування, що дає змогу об’єктам із несумісними інтерфейсами працювати разом.

####  Застосування:
Якщо ви хочете використати сторонній клас, але його інтерфейс не відповідає решті кодів програми.
Якщо вам потрібно використати декілька існуючих підкласів, але в них не вистачає якої-небудь спільної функціональності, а розширити суперклас ви не можете.

#### Основні компоненти фасаду:
1) Фасад (Facade): Клас, який містить методи для взаємодії з підсистемою, забезпечуючи простий інтерфейс для користувача.
2) Підсистема (Subsystem): Набір класів або компонентів, які реалізують конкретну функціональність системи. Фасад надає доступ до цих компонентів.

#### Кроки реалізації:
1) Переконайтеся, що у вас є два класи з незручними інтерфейсами:
-  корисний сервіс службовий клас, який ви не можете змінювати (він або сторонній, або від нього залежить інший код);
-  один або декілька клієнтів — існуючих класів програми, які не можуть використовувати сервіс через несумісний із ним інтерфейс.
2) Опишіть клієнтський інтерфейс, через який класи програм могли б використовувати клас сервісу.
3) Створіть клас адаптера, реалізувавши цей інтерфейс.
4) Розмістіть в адаптері поле, що міститиме посилання на об’єкт сервісу. Зазвичай це поле заповнюють об’єктом, переданим у конструктор адаптера. Але цей об’єкт можна передавати й безпосередньо до методів адаптера. 
5) Реалізуйте всі методи клієнтського інтерфейсу в адаптері. Адаптер повинен делегувати основну роботу сервісу.
6) Програма повинна використовувати адаптер тільки через клієнтський інтерфейс. Це дозволить легко змінювати та додавати адаптери в майбутньому.
#### UML-diagram класу
```mermaid
classDiagram
    class Target {
        +request(): str
    }

    class Adaptee {
        +specific_request(): str
    }

    class Adapter {
        +request(): str
    }

    Target <|-- Adapter
    Adapter --> Adaptee

```
---

### Висновок
У ході виконання лабораторної роботи №2 на тему "Структурні патерни проектування" я ознайомився з основами структурних патернів, їхньою метою та застосуванням у програмуванні. Особливу увагу було приділено патерну "Адаптер", який дозволяє об'єктам з несумісними інтерфейсами працювати разом.

Я вивчив основні компоненти патерну "Адаптер", такі як цільовий інтерфейс, клас адаптера та адаптований клас. Це допомогло зрозуміти, як можна використовувати цей патерн для інтеграції різних класів у програмі.

Також я реалізував приклад коду, що демонструє роботу патерну, та створив UML-діаграму, яка ілюструє архітектуру взаємодії між компонентами.