# Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій

### Звіт про виконання лабораторної роботи №5
### Тема: "Рефакторинг програмного забезпечення
"

| Виконав: студент групи КН-31 Грицків Тарас |  
| ------------------------------------------ |  
| Перевірив: Татомир Андрій                  |  

---

### Мета
Познайомитися з основними принципами та найбільш поширеними техніками рефакторингу програмного забезпечення.
---

### Хід роботи

1. Дати загальний опис принципів рефакторингу.
2. Ознайомитися із основними техніками рефакторингу.
3. Познайомитися із поняттям “запахів коду”.

---

# Чистий код

### Рефакторинг: перетворення брудного коду на чистий
Основна мета рефакторингу — перетворити брудний код у чистий та зрозумілий. Чистий код робить програму більш зрозумілою та простою в підтримці.

### Вимоги до чистого коду

- **Проходження усіх тестів**  
  Якщо ваш код проходить лише 95% тестів, це свідчить про наявність проблемних місць. А за відсутності тестів, перевірка чистоти коду взагалі ускладнюється.

- **Очевидність для інших розробників**  
  Чистий код має бути зрозумілим для колег-програмістів, без необхідності розбиратися в складних алгоритмах. Погане іменування змінних, великі класи та методи ускладнюють читання та розуміння.

- **Відсутність дублювання**  
  Повторюваний код призводить до складностей при внесенні змін. Якщо ви змінюєте одну ділянку коду, не забувайте вносити такі самі зміни й в інших місцях, де код повторюється.

- **Мінімальна кількість класів та рухомих частин**  
  Чим менше коду, тим простіше його розуміти та підтримувати. Менше деталей означає менше шансів щось зламати під час змін.

### Переваги чистого коду

Чистий код значно спрощує підтримку та здешевлює майбутні доопрацювання.

# Технічний борг

### Що таке технічний борг?
Більшість програмістів прагнуть писати чистий код із самого початку проєкту. Проте, навіть із найкращими намірами, код з часом починає накопичувати "бруд". Метафору "технічного боргу" вперше запропонував Говард Канінгем.

Подібно до банківського кредиту, технічний борг дозволяє швидше досягти короткострокових цілей, але згодом вимагає виплати не лише основного боргу, а й відсотків. З часом, якщо накопичувати борг без погашення, це може повністю зупинити розвиток проєкту.

### Причини виникнення технічного боргу

- **Тиск зі сторони бізнесу**  
  Коли бізнес вимагає швидкого запуску нових функцій, розробники змушені йти на компроміси. Це призводить до появи "заплаток" та швидких рішень, що приховують недоробки.

- **Відсутність розуміння наслідків**  
  Часто керівництво не усвідомлює, що технічний борг уповільнює розробку. Внаслідок цього команди не отримують достатньо часу на рефакторинг, оскільки його цінність залишається непомітною.

- **Жорстка зв'язаність компонентів**  
  Якщо проєкт побудований як моноліт, будь-які зміни однієї частини впливають на інші. Це ускладнює командну розробку, оскільки складно ізолювати зони відповідальності.

- **Відсутність авто-тестів**  
  Без швидкого зворотного зв’язку ризиковані виправлення вносяться прямо на продакшн. Це може призвести до катастрофічних наслідків, як-от випадкове видалення даних або розсилка тестових повідомлень клієнтам.

- **Відсутність документації**  
  Застаріла або відсутня документація ускладнює адаптацію нових членів команди. Якщо ключові співробітники покинуть проєкт, його розвиток може повністю зупинитися.

- **Низька взаємодія між членами команди**  
  Якщо знання не поширюються всередині команди, співробітники працюють із застарілою інформацією, а новачки навчаються неправильних практик.

- **Довготривала розробка в окремих гілках**  
  Тривале ведення розробки в окремих гілках призводить до накопичення технічного боргу. Під час об'єднання змін виникають конфлікти, що ускладнюють інтеграцію.

- **Відкладений рефакторинг**  
  Вимоги до проєкту постійно змінюються, і деякі частини коду застарівають. Чим довше відкладати рефакторинг, тим більше коду доведеться оновлювати пізніше.

- **Відсутність стандартів кодування**  
  Кожен розробник пише код у своєму стилі, що призводить до змішування різних підходів у проєкті. Це ускладнює підтримку та розуміння коду іншими членами команди.

- **Низький рівень компетенції**  
  Коли розробник не володіє навичками написання чистого коду, це автоматично створює технічний борг.

# Коли рефакторити

### Правило трьох
- **Перша реалізація**: Просто виконуєте завдання.
- **Друга реалізація**: Ви відчуваєте дискомфорт через повторення, але все ж копіюєте існуюче рішення.
- **Третя реалізація**: Якщо виникає потреба зробити щось схоже втретє, саме час розпочати рефакторинг. Це сигнал, що потрібно оптимізувати код, аби уникнути дублювання.

### Під час розробки нових фіч
- **Покращення розуміння коду**  
  Додавання нових функцій у незрозумілий код може бути складним. Рефакторинг дозволяє структурувати код так, щоб зробити його більш зрозумілим і для вас, і для майбутніх розробників.
  
- **Полегшення написання нового коду**  
  Після рефакторингу процес інтеграції нової фічі стає значно простішим і швидшим, що зменшує затрати часу.

### Під час виправлення багів
- **Помилки часто ховаються в "темних куточках" коду**  
  Рефакторинг перед усуненням помилок допомагає знайти приховані проблеми та зробити код більш читабельним. Виправлення багів у чистішому коді — набагато легше завдання.

- **Уникнення окремих завдань на рефакторинг**  
  Оскільки рефакторинг відбувається під час виправлення багів, не потрібно створювати додаткові завдання, які зазвичай не подобаються менеджерам.

### Під час код-рев'ю
- **Останній шанс покращити код перед релізом**  
  Рефакторинг під час рев'ю дозволяє впровадити останні зміни, щоб підготувати код до релізу.

- **Спільне обговорення з автором коду**  
  Спільне рев'ю з автором дозволяє не лише запропонувати покращення, але й разом оцінити складність змін. Невеликі покращення можуть бути внесені миттєво, що підвищує якість кінцевого продукту.


# Як рефакторити код

Рефакторинг слід проводити серією **невеликих змін**, кожна з яких робить існуючий код трохи чистішим, залишаючи програму в робочому стані.

### Чек-ліст правильно проведеного рефакторингу:

1. **Код повинен стати чистішим**  
   Якщо після рефакторингу код залишився таким же неохайним, це означає, що ви даремно витратили свій час. Важливо зрозуміти, чому це сталося:

   - **Змішування великих змін**: Уникати великих "глобальних" змін, що можуть призвести до хаосу. Проводьте рефакторинг поступово, дрібними кроками, особливо якщо часу обмаль.
   - **Занедбаний код**: У випадку дуже складного та старого коду іноді єдиний вихід — переписати певні частини з нуля. Але перед цим обов'язково забезпечте наявність тестів і виділіть достатньо часу.

2. **Не створюйте нову функціональність під час рефакторингу**  
   Рефакторинг не має включати розробку нових фіч. Розділяйте процеси хоча б на рівні окремих комітів, щоб уникнути плутанини.

3. **Всі існуючі тести повинні успішно проходити**  
   Якщо після рефакторингу ламаються тести, розгляньте дві можливі причини:

   - **Помилка в коді**: Ви могли зробити помилку під час змін. Просто виправте її.
   - **Низькорівневі тести**: Іноді тести, що перевіряють приватні методи або деталі реалізації, перестають працювати. У такому випадку краще **відрефакторити самі тести** або написати нові, більш високорівневі. 


# Каталог рефакторингу

## Запахи коду

### Роздувальники
Код, методи та класи, які з часом розростаються до таких масштабів, що їх стає важко підтримувати. Ці запахи з’являються поступово в процесі еволюції коду.

- **Long Method** (довгий метод)
- **Large Class** (роздутий клас)
- **Primitive Obsession** (одержимість примітивами)
- **Long Parameter List** (довгі списки параметрів)
- **Data Clumps** (згустки даних)

### Порушники об'єктного дизайну
Свідчать про недостатнє або неправильне використання об'єктно-орієнтованого підходу.

- **Alternative Classes with Different Interfaces** (альтернативні класи з різними інтерфейсами)
- **Refused Bequest** (відмова від наслідування)
- **Temporary Field** (тимчасові поля)

### Ускладнювачі змін
Призводять до того, що зміни в одній частині коду потребують модифікацій в інших місцях, що ускладнює підтримку.

- **Divergent Change** (розходження змін)
- **Parallel Inheritance Hierarchies** (паралельні ієрархії наслідування)
- **Shotgun Surgery** (дрібнокаліберна хірургія)

### Забруднювачі коду
Зайві елементи, які ускладнюють розуміння коду.

- **Comments** (надмірні коментарі)
- **Duplicate Code** (дублювання коду)
- **Data Class** (класи даних)
- **Dead Code** (мертвий код)
- **Lazy Class** (лінивий клас)
- **Speculative Generality** (спекулятивні узагальнення)

### Заплутувальники зв'язками
Призводять до надмірної зв'язаності між класами або до заміни тісної зв'язаності надмірним делегуванням.

- **Feature Envy** (заздрість до функцій)
- **Inappropriate Intimacy** (надмірна близькість)
- **Incomplete Library Class** (недосконалий клас бібліотеки)
- **Message Chains** (ланцюжки повідомлень)
- **Middle Man** (посередник)

## Прийоми рефакторингу

### Складання методів
Методи часто стають занадто довгими та складними, що приховує логіку та ускладнює зміни. Прийоми для зменшення складності та усунення дублювання:

- **Extract Method** (виділити метод)
- **Inline Method** (вбудувати метод)
- **Extract Variable** (виділити змінну)
- **Inline Temp** (вбудувати тимчасову змінну)
- **Replace Temp with Query** (заміна тимчасової змінної запитом)
- **Split Temporary Variable** (розділити тимчасову змінну)
- **Remove Assignments to Parameters** (усунути присвоєння параметрам)
- **Replace Method with Method Object** (замінити метод об’єктом методу)
- **Substitute Algorithm** (замінити алгоритм)

### Переміщення функцій між об'єктами
Переміщення функцій для покращення архітектури проєкту:

- **Move Method** (перемістити метод)
- **Move Field** (перемістити поле)
- **Extract Class** (виділити клас)
- **Inline Class** (вбудувати клас)
- **Hide Delegate** (приховати делегата)
- **Remove Middle Man** (прибрати посередника)
- **Introduce Foreign Method** (додати зовнішній метод)
- **Introduce Local Extension** (ввести локальне розширення)

### Організація даних
Полегшення роботи з даними та зменшення зв'язаності:

- **Change Value to Reference** (заміна значення на посилання)
- **Change Reference to Value** (заміна посилання на значення)
- **Duplicate Observed Data** (дублювати дані спостереження)
- **Self Encapsulate Field** (самоінкапсуляція поля)
- **Replace Data Value with Object** (замінити значення даних об’єктом)
- **Replace Array with Object** (замінити масив об’єктом)
- **Encapsulate Field** (інкапсуляція поля)
- **Replace Magic Number with Symbolic Constant** (заміна магічного числа символічною константою)

### Спрощення умовних виразів
Умовні конструкції мають тенденцію до ускладнення. Прийоми для спрощення:

- **Consolidate Conditional Expression** (об'єднати умовні вирази)
- **Decompose Conditional** (розкласти умовний вираз)
- **Replace Conditional with Polymorphism** (замінити умовний оператор поліморфізмом)
- **Introduce Null Object** (ввести Null Object)
- **Replace Nested Conditional with Guard Clauses** (замінити вкладені умовні оператори захисними виразами)

### Спрощення викликів методів
Спрощення інтерфейсів та викликів:

- **Add Parameter** (додати параметр)
- **Remove Parameter** (видалити параметр)
- **Rename Method** (перейменувати метод)
- **Parameterize Method** (параметризувати метод)
- **Introduce Parameter Object** (ввести об’єкт параметра)
- **Replace Parameter with Method Call** (замінити параметр викликом методу)

### Узагальнення об'єктів
Рефакторинг для роботи з ієрархією класів та заміни наслідування делегуванням:

- **Pull Up Method** (підняти метод)
- **Push Down Method** (опустити метод)
- **Extract Subclass** (виділити підклас)
- **Extract Superclass** (виділити суперклас)
- **Extract Interface** (виділити інтерфейс)
- **Replace Inheritance with Delegation** (замінити наслідування делегуванням)

# Прийоми рефакторингу

## Складання методів
Значна частина рефакторингу присвячена правильному складанню методів. У більшості випадків коренем проблем є занадто довгі методи, що приховують логіку та ускладнюють розуміння і зміни. Прийоми цієї групи спрямовані на зменшення складності, усунення дублювання коду та полегшення подальшої роботи з ним.

- **Extract Method** (виділити метод)
- **Inline Method** (вбудувати метод)
- **Extract Variable** (виділити змінну)
- **Inline Temp** (вбудувати тимчасову змінну)
- **Replace Temp with Query** (заміна тимчасової змінної запитом)
- **Split Temporary Variable** (розділити тимчасову змінну)
- **Remove Assignments to Parameters** (усунути присвоєння параметрам)
- **Replace Method with Method Object** (замінити метод об’єктом методу)
- **Substitute Algorithm** (замінити алгоритм)

## Переміщення функцій між об'єктами
Якщо функціональність була розподілена по класах не найоптимальнішим чином, це можна виправити без повного переписування. Прийоми цієї групи дозволяють безпечно переміщати функції між класами, створювати нові класи та приховувати деталі реалізації.

- **Move Method** (перемістити метод)
- **Move Field** (перемістити поле)
- **Extract Class** (виділити клас)
- **Inline Class** (вбудувати клас)
- **Hide Delegate** (приховати делегата)
- **Remove Middle Man** (прибрати посередника)
- **Introduce Foreign Method** (додати зовнішній метод)
- **Introduce Local Extension** (ввести локальне розширення)

## Організація даних
Прийоми цієї групи покращують роботу з даними, замінюючи використання примітивних типів багатими функціональними класами. Вони також допомагають зменшити зв'язаність між класами, підвищуючи переносимість та повторне використання.

- **Change Value to Reference** (заміна значення на посилання)
- **Change Reference to Value** (заміна посилання на значення)
- **Duplicate Observed Data** (дублювати спостережувані дані)
- **Self Encapsulate Field** (самоінкапсуляція поля)
- **Replace Data Value with Object** (замінити значення даних об’єктом)
- **Replace Array with Object** (замінити масив об’єктом)
- **Change Unidirectional Association to Bidirectional** (заміна односторонньої асоціації на двосторонню)
- **Change Bidirectional Association to Unidirectional** (заміна двосторонньої асоціації на односторонню)
- **Encapsulate Field** (інкапсуляція поля)
- **Encapsulate Collection** (інкапсуляція колекції)
- **Replace Magic Number with Symbolic Constant** (заміна магічного числа символічною константою)
- **Replace Type Code with Class/Subclasses/State** (заміна коду типу на клас/підкласи/стратегію)
- **Replace Subclass with Fields** (замінити підклас полями)

## Спрощення умовних виразів
Умовні конструкції мають тенденцію ускладнюватися, тому прийоми для спрощення логіки є важливими для поліпшення читабельності та підтримки.

- **Consolidate Conditional Expression** (об'єднати умовні вирази)
- **Consolidate Duplicate Conditional Fragments** (об'єднати дубльовані фрагменти умов)
- **Decompose Conditional** (розкласти умовний вираз)
- **Replace Conditional with Polymorphism** (замінити умовний оператор поліморфізмом)
- **Remove Control Flag** (прибрати прапорець управління)
- **Replace Nested Conditional with Guard Clauses** (замінити вкладені умовні оператори захисними виразами)
- **Introduce Null Object** (ввести Null Object)
- **Introduce Assertion** (ввести твердження)

## Спрощення викликів методів
Прийоми, що спрощують виклики методів, допомагають зробити інтерфейси між класами більш зрозумілими та легкими для використання.

- **Add Parameter** (додати параметр)
- **Remove Parameter** (видалити параметр)
- **Rename Method** (перейменувати метод)
- **Separate Query from Modifier** (відокремити запит від модифікатора)
- **Parameterize Method** (параметризувати метод)
- **Introduce Parameter Object** (ввести об’єкт параметра)
- **Preserve Whole Object** (зберегти весь об’єкт)
- **Remove Setting Method** (прибрати метод встановлення значення)
- **Replace Parameter with Explicit Methods** (замінити параметр на явні методи)
- **Replace Parameter with Method Call** (замінити параметр викликом методу)
- **Hide Method** (приховати метод)
- **Replace Constructor with Factory Method** (замінити конструктор фабричним методом)
- **Replace Error Code with Exception** (замінити код помилки на виняток)
- **Replace Exception with Test** (замінити виняток на тест)

## Задачі узагальнення об'єктів
Прийоми для оптимізації ієрархій класів та заміни наслідування делегуванням, або навпаки.

- **Pull Up Field** (підняти поле)
- **Pull Up Method** (підняти метод)
- **Pull Up Constructor Body** (підняти тіло конструктора)
- **Push Down Field** (опустити поле)
- **Push Down Method** (опустити метод)
- **Extract Subclass** (виділити підклас)
- **Extract Superclass** (виділити суперклас)
- **Extract Interface** (виділити інтерфейс)
- **Collapse Hierarchy** (спростити ієрархію)
- **Form Template Method** (створити шаблонний метод)
- **Replace Inheritance with Delegation** (замінити наслідування делегуванням)
- **Replace Delegation with Inheritance** (замінити делегування наслідуванням)

# Рефакторинг: Переміщення методу

## Ситуація до рефакторингу
Припустімо, у нас є дві сутності: `Order` (Замовлення) та `Customer` (Клієнт).  
У класі `Order` є метод для розрахунку знижки. Однак цей метод використовує дані, що зберігаються у класі `Customer`, тому логічніше перемістити цей метод до класу `Customer`.

## Проблема
Метод `calculate_discount()` знаходиться в класі `Order`, але використовує дані (`loyalty_points`) із класу `Customer`.  
Це створює тісну зв'язаність між класами.

## Рішення: Переміщення методу
Перенесемо метод `calculate_discount()` до класу `Customer`, оскільки знижка залежить від інформації про клієнта, а не про замовлення.

## Пояснення змін
- Метод `calculate_discount()` перенесено до класу `Customer`, оскільки знижка розраховується на основі даних про клієнта.  
- У класі `Order` залишився лише метод `get_discount()`, який викликає метод клієнта для обчислення знижки.  
- Тепер клас `Order` не залежить від деталей реалізації розрахунку знижки, що підвищує гнучкість та полегшує підтримку.

## Переваги рефакторингу
- **Зниження зв'язаності між класами**: тепер класи менш залежні один від одного.  
- **Логічне розділення**: методи знаходяться там, де їм логічно належить бути.  
- **Полегшена підтримка та розширюваність**: якщо логіка знижок зміниться, потрібно буде змінювати лише клас `Customer`.

## Пояснення рефакторингу
Метод `calculate_discount()` було перенесено до класу `Customer`, оскільки він використовує дані клієнта (`loyalty_points`).  
У класі `Order` залишився лише метод `get_discount()`, який викликає метод клієнта для обчислення знижки.

### Переваги
- Зниження зв'язаності між класами.  
- Логічне розділення функціональності — тепер методи знаходяться там, де їм належить бути.  
- Легше підтримувати код та вносити зміни у майбутньому.

---

## Посилання на файл
Код можна знайти у файлі (./code_before_refactoring.py).
Код можна знайти у файлі [`code_after_refactoring.py`](./code_after_refactoring.py).

# Висновок до лабораторної роботи

На даній лабораторній роботі я вивчив основи рефакторингу коду, ознайомився з різними методами покращення коду, такими як **"переміщення методів"** та **"покращення організації даних"**.  

Я засвоїв принципи чистого коду, включаючи розуміння важливості:  
- Читабельності.  
- Підтримуваності.  
- Тестування коду.  

Особливо важливим було розуміння того, як:  
- Правильно розподіляти функціональність між класами та методами.  
- Уникати дублювання і складних зв'язків між компонентами програми.  

Завдяки цій роботі я значно покращив свої навички в рефакторингу та підвищив здатність оптимізувати існуючий код, роблячи його більш зрозумілим і ефективним.
