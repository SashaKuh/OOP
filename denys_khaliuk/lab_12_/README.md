## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій



### Звіт про виконання лабораторної роботи №2
# "Поведінкові шаблони проєктування"



| Виконав: студент групи КН-31 Халюк Денис |
|------------------------------------------|
| Перевірив: Татомир Андрій                |




**Мета: Познайомитися з групою поведінкових шаблонів**


Хід роботи

1. Дати теоретичний опис поведінкових групи шаблонів.
2. Дати теоретичний опис вибраного шаблону.
3. Навести приклад коду який реалізовує даний шаблон.
4. Скласти його UML-діаграму.

Поведінкові патерни проєктування - це шаблони які вирішують завдання ефективної та безпечної взаємодії між об'єктами програми.

**Існують такі твірні патерни проєктування:**

<<<<<<< HEAD
    	Ланцюжок обов’язків — це поведінковий патерн проектування, що дає змогу передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам і чи варто передавати запит далі ланцюжком.
=======
- Адаптер — це структурний патерн проєктування, що дає змогу об’єктам із несумісними інтерфейсами працювати разом.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Команда — це поведінковий патерн проектування, який перетворює запити на об’єкти, дозволяючи передавати їх як аргументи під час виклику методів, ставити запити в чергу, логувати їх, а також підтримувати скасування операцій.
=======
- Міст — це структурний патерн проєктування, який розділяє один або кілька класів на дві окремі ієрархії — абстракцію та реалізацію, дозволяючи змінювати код в одній гілці класів, незалежно від іншої.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Ітератор — це поведінковий патерн проектування, що дає змогу послідовно обходити елементи складових об’єктів, не розкриваючи їхньої внутрішньої організації.
=======
- Компонувальник — це структурний патерн проєктування, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Посередник — це поведінковий патерн проектування, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.
=======
- Декоратор — це структурний патерн проєктування, що дає змогу динамічно додавати об’єктам нову функціональність, загортаючи їх у корисні «обгортки».
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Знімок — це поведінковий патерн проектування, що дає змогу зберігати та відновлювати минулий стан об’єктів, не розкриваючи подробиць їхньої реалізації.
=======
- Фасад — це структурний патерн проєктування, який надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Спостерігач — це поведінковий патерн проектування, який створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах.
=======
- Легковаговик — це структурний патерн проєктування, що дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Легковаговик заощаджує пам’ять, розподіляючи спільний стан об’єктів між собою, замість зберігання однакових даних у кожному об’єкті.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Стан — це поведінковий патерн проектування, що дає змогу об’єктам змінювати поведінку в залежності від їхнього стану. Ззовні створюється враження, ніби змінився клас об’єкта.
=======
- Замісник — це структурний патерн проєктування, що дає змогу підставляти замість реальних об’єктів спеціальні об’єкти-замінники. Ці об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналові.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

    	Стратегія — це поведінковий патерн проектування, який визначає сімейство схожих алгоритмів і розміщує кожен з них у власному класі. Після цього алгоритми можна заміняти один на інший прямо під час виконання програми.

    	Шаблонний метод — це поведінковий патерн проектування, який визначає кістяк алгоритму, перекладаючи відповідальність за деякі його кроки на підкласи. Патерн дозволяє підкласам перевизначати кроки алгоритму, не змінюючи його загальної структури.

    	Відвідувач — це поведінковий патерн проектування, що дає змогу додавати до програми нові операції, не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.

**Для чого використовують шаблони проєктування:**

На відміну від готових функцій чи бібліотек, патерн не можна просто взяти й скопіювати в програму. Патерн являє собою не якийсь конкретний код, а загальний принцип вирішення певної проблеми, який майже завжди треба підлаштовувати для потреб тієї чи іншої програми.

Патерни часто плутають з алгоритмами, адже обидва поняття описують типові рішення відомих проблем. Але якщо алгоритм — це чіткий набір дій, то патерн — це високорівневий опис рішення, реалізація якого може відрізнятися у двох різних програмах.

Якщо провести аналогії, то алгоритм — це кулінарний рецепт з чіткими кроками, а патерн — інженерне креслення, на якому намальовано рішення без конкретних кроків його отримання.

**Опис коду у файлі Lab_12:**

<<<<<<< HEAD
    	Клас Observer: Визначає інтерфейс для спостерігачів, які повинні реалізувати метод update(), що приймає температуру.
=======
Клас AudioSystem: Відповідає за управління аудіосистемою.
- Метод on: Увімкнення аудіосистеми.
- Метод set_volume: Налаштування гучності.
- Метод off: Вимкнення аудіосистеми.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Клас WeatherStation: Відповідає за управління списком спостерігачів та їх сповіщенням про зміни температури.
                 Метод register_observer: Додає нового спостерігача до списку.
                 Метод remove_observer: Видаляє спостерігача зі списку.
                 Метод set_temperature: Задає нове значення температури та сповіщає всіх зареєстрованих спостерігачів.
                 Метод notify_observers: Сповіщає всіх спостерігачів про зміни температури, викликаючи їх метод update().
=======
Клас VideoPlayer: Відповідає за управління відеоплеєром.
- Метод on: Увімкнення відеоплеєра.
- Метод play: Відтворення фільму.
- Метод off: Вимкнення відеоплеєра.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Клас TemperatureDisplay: Реалізує інтерфейс Observer та відображає температуру на екрані.
                 Метод update: Виводить на екран поточну температуру.
=======
Клас Subtitles: Відповідає за керування субтитрами.
- Метод on: Увімкнення субтитрів.
- Метод off: Вимкнення субтитрів.
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD
    	Клас TemperatureAlert: Реалізує інтерфейс Observer та реагує на зміни температури.
                 Метод update: Перевіряє, чи температура перевищує 30°C, і, якщо так, видає попередження.
=======
Клас HomeTheaterFacade: Фасад для домашнього кінотеатру, який спрощує взаємодію з підсистемами (аудіо, відео та субтитрами).
- Метод watch_movie: Вмикає аудіосистему, відеоплеєр і субтитри для відтворення фільму.
- Метод end_movie: Вимикає всі підсистеми (субтитри, відеоплеєр та аудіосистему).
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

    	Використання:
                 У головному блоці коду створюється об'єкт WeatherStation, а також два спостерігачі: TemperatureDisplay і TemperatureAlert.
                 Спостерігачі реєструються в WeatherStation.
                 Зміни температури у WeatherStation призводять до сповіщення спостерігачів, які виконують відповідні дії.

**Переваги цього підходу:**

<<<<<<< HEAD
    	Можливість легко додавати нові спостерігачі без зміни суб'єкта.
    	Зменшує зв'язність між компонентами.
=======
Можиливість надати простий або урізаний інтерфейс до складної підсистеми.
Можливість розкласти підсистему на окремі рівні.
     
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59
**Можливі розширення:**

<<<<<<< HEAD
    	Реалізувати різні типи спостерігачів для різних функцій, наприклад, спостерігачі для вологості, тиску або прогнозу погоди, які реагують на зміни в інших параметрах.
    	Додати можливість відкладеного сповіщення спостерігачів, щоб вони могли отримувати дані не відразу, а через певний проміжок часу, що може бути корисним у випадках, коли дані часто змінюються.
    	Реалізувати можливість зберігання історії температури в об'єкті WeatherStation, щоб спостерігачі могли отримувати не лише останнє значення, а й історичні дані.
=======
Додати підтримку нових підсистем: Можна інтегрувати інші підсистеми, такі як освітлення або клімат-контроль, які будуть керувати освітленням або температурою в кімнаті під час перегляду фільму.
Впровадити налаштування профілів: Додати можливість створювати профілі для різних користувачів, щоб кожен міг мати свої налаштування аудіо, відео та субтитрів для перегляду.
Використання шаблонного методу: Створити шаблонний метод для налаштування різних сценаріїв перегляду фільмів, наприклад: "Нічний режим" (низька гучність, вимкнене освітлення) чи "Денний режим" (висока яскравість екрану, увімкнене освітлення).
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59


<<<<<<< HEAD
Ознайомився з поведінковою групою шаблонів проєктування та на практиці закріпив такий шаблон як спостерігач.

=======
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59
```mermaid
classDiagram
    class Observer {
        <<interface>>
        +update(temperature: float)
    }

    class WeatherStation {
        -_observers: List<Observer>
        -_temperature: float
        +register_observer(observer: Observer)
        +remove_observer(observer: Observer)
        +set_temperature(temperature: float)
        +notify_observers()
    }

    class TemperatureDisplay {
        +update(temperature: float)
    }

    class TemperatureAlert {
        +update(temperature: float)
    }

<<<<<<< HEAD
    WeatherStation --|> Observer
    TemperatureDisplay --|> Observer
    TemperatureAlert --|> Observer
=======
```
>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59

<<<<<<< HEAD



=======
---

### Висновок

На даній лабораторній роботі я навчився принципам роботи з структурними патернами проектування, зокрема, з патерном **Фасад**. На практиці я засвоїв, як використовувати ітератори для послідовного доступу до елементів складних структур даних, а також розібрався з їх перевагами та недоліками.

---

>>>>>>> ec01054d3821ff48b4b38377ed478373bc198a59
