## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій



### Звіт про виконання лабораторної роботи №2
# "Поведінкові шаблони проєктування"



| Виконав: студент групи КН-31 Халюк Денис |
|------------------------------------------|
| Перевірив: Татомир Андрій                |




**Мета: Познайомитися з групою поведінкових шаблонів**


Хід роботи

1. Дати теоретичний опис поведінкових групи шаблонів.
2. Дати теоретичний опис вибраного шаблону.
3. Навести приклад коду який реалізовує даний шаблон.
4. Скласти його UML-діаграму.

Поведінкові патерни проєктування - це шаблони які вирішують завдання ефективної та безпечної взаємодії між об'єктами програми.

**Існують такі твірні патерни проєктування:**

    •	Ланцюжок обов’язків — це поведінковий патерн проектування, що дає змогу передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам і чи варто передавати запит далі ланцюжком.

    •	Команда — це поведінковий патерн проектування, який перетворює запити на об’єкти, дозволяючи передавати їх як аргументи під час виклику методів, ставити запити в чергу, логувати їх, а також підтримувати скасування операцій.

    •	Ітератор — це поведінковий патерн проектування, що дає змогу послідовно обходити елементи складових об’єктів, не розкриваючи їхньої внутрішньої організації.

    •	Посередник — це поведінковий патерн проектування, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.

    •	Знімок — це поведінковий патерн проектування, що дає змогу зберігати та відновлювати минулий стан об’єктів, не розкриваючи подробиць їхньої реалізації.

    •	Спостерігач — це поведінковий патерн проектування, який створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах.

    •	Стан — це поведінковий патерн проектування, що дає змогу об’єктам змінювати поведінку в залежності від їхнього стану. Ззовні створюється враження, ніби змінився клас об’єкта.

    •	Стратегія — це поведінковий патерн проектування, який визначає сімейство схожих алгоритмів і розміщує кожен з них у власному класі. Після цього алгоритми можна заміняти один на інший прямо під час виконання програми.

    •	Шаблонний метод — це поведінковий патерн проектування, який визначає кістяк алгоритму, перекладаючи відповідальність за деякі його кроки на підкласи. Патерн дозволяє підкласам перевизначати кроки алгоритму, не змінюючи його загальної структури.

    •	Відвідувач — це поведінковий патерн проектування, що дає змогу додавати до програми нові операції, не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.

**Для чого використовують шаблони проєктування:**

    •	На відміну від готових функцій чи бібліотек, патерн не можна просто взяти й скопіювати в програму. Патерн являє собою не якийсь конкретний код, а загальний принцип вирішення певної проблеми, який майже завжди треба підлаштовувати для потреб тієї чи іншої програми.

    •	Патерни часто плутають з алгоритмами, адже обидва поняття описують типові рішення відомих проблем. Але якщо алгоритм — це чіткий набір дій, то патерн — це високорівневий опис рішення, реалізація якого може відрізнятися у двох різних програмах.

    •	Якщо провести аналогії, то алгоритм — це кулінарний рецепт з чіткими кроками, а патерн — інженерне креслення, на якому намальовано рішення без конкретних кроків його отримання.

**Опис коду у файлі Lab_12:**

    •	Клас Observer: Визначає інтерфейс для спостерігачів, які повинні реалізувати метод update(), що приймає температуру.

    •	Клас WeatherStation: Відповідає за управління списком спостерігачів та їх сповіщенням про зміни температури.
                o Метод register_observer: Додає нового спостерігача до списку.
                o Метод remove_observer: Видаляє спостерігача зі списку.
                o Метод set_temperature: Задає нове значення температури та сповіщає всіх зареєстрованих спостерігачів.
                o Метод notify_observers: Сповіщає всіх спостерігачів про зміни температури, викликаючи їх метод update().

    •	Клас TemperatureDisplay: Реалізує інтерфейс Observer та відображає температуру на екрані.
                o Метод update: Виводить на екран поточну температуру.

    •	Клас TemperatureAlert: Реалізує інтерфейс Observer та реагує на зміни температури.
                o Метод update: Перевіряє, чи температура перевищує 30°C, і, якщо так, видає попередження.

    •	Використання:
                o У головному блоці коду створюється об'єкт WeatherStation, а також два спостерігачі: TemperatureDisplay і TemperatureAlert.
                o Спостерігачі реєструються в WeatherStation.
                o Зміни температури у WeatherStation призводять до сповіщення спостерігачів, які виконують відповідні дії.

**Переваги цього підходу:**

    •	Можливість легко додавати нові спостерігачі без зміни суб'єкта.
    •	Зменшує зв'язність між компонентами.
**Можливі розширення:**

    •	Реалізувати різні типи спостерігачів для різних функцій, наприклад, спостерігачі для вологості, тиску або прогнозу погоди, які реагують на зміни в інших параметрах.
    •	Додати можливість відкладеного сповіщення спостерігачів, щоб вони могли отримувати дані не відразу, а через певний проміжок часу, що може бути корисним у випадках, коли дані часто змінюються.
    •	Реалізувати можливість зберігання історії температури в об'єкті WeatherStation, щоб спостерігачі могли отримувати не лише останнє значення, а й історичні дані.

**Висновок:**

Ознайомився з поведінковою групою шаблонів проєктування та на практиці закріпив такий шаблон як спостерігач.

```mermaid
classDiagram
    class Observer {
        <<interface>>
        +update(temperature: float)
    }

    class WeatherStation {
        -_observers: List<Observer>
        -_temperature: float
        +register_observer(observer: Observer)
        +remove_observer(observer: Observer)
        +set_temperature(temperature: float)
        +notify_observers()
    }

    class TemperatureDisplay {
        +update(temperature: float)
    }

    class TemperatureAlert {
        +update(temperature: float)
    }

    WeatherStation --|> Observer
    TemperatureDisplay --|> Observer
    TemperatureAlert --|> Observer



