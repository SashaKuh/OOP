## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій

### Звіт про виконання лабораторної роботи №11
# "Твірні шаблони проєктування"

| Виконав: студент групи КН-31 Ковташ Іван |
|------------------------------------------|
| Перевірив: Татомир Андрій                |

**Мета:** Ознайомитися з групою твірних шаблонів

### Хід роботи

1. Надати теоретичний опис групи твірних шаблонів.
2. Описати вибраний шаблон.
3. Привести приклад коду, що реалізує даний шаблон.
4. Скласти UML-діаграму.

Твірні патерни проєктування — це шаблони, які допомагають ефективно та безпечно створювати нові об'єкти або цілі їхні сімейства.

**Основні типи твірних патернів:**

- **Фабричний метод** — це патерн, що дозволяє визначити загальний інтерфейс для створення об’єктів у суперкласі, при цьому підкласи можуть змінювати тип створюваних об’єктів.

- **Абстрактна фабрика** — це патерн, який забезпечує можливість створення сімейств пов’язаних об’єктів, не прив’язуючись до конкретних класів.

- **Будівельник** — це патерн, що дозволяє поетапно створювати складні об’єкти. Він дозволяє використовувати один і той самий код для отримання різних варіантів об’єктів.

- **Прототип** — це патерн, що дає змогу копіювати об’єкти без детального розуміння їхньої реалізації.

- **Одинак** — це патерн, який гарантує, що клас має лише один екземпляр, і надає глобальну точку доступу до нього.

**Для чого використовують шаблони проєктування:**

- На відміну від стандартних функцій чи бібліотек, патерни не можна просто скопіювати в програму. Це загальні принципи вирішення певних проблем, які зазвичай потрібно адаптувати під конкретні вимоги проекту.

- Патерни часто плутають з алгоритмами, адже обидва концепти описують типові рішення для відомих проблем. Але алгоритм — це чіткий набір дій, тоді як патерн — це загальний опис рішення, реалізація якого може відрізнятися в різних програмах.

- Якщо провести аналогію, алгоритм можна порівняти з кулінарним рецептом, що містить конкретні інструкції, а патерн — з інженерним кресленням, яке демонструє рішення без детальних кроків.

**Коли доцільно використовувати певний шаблон:**

- **Фабричний метод:** якщо необхідно створювати об'єкти різних класів залежно від певних умов.

- **Абстрактна фабрика:** коли потрібно створювати пов'язані об'єкти, які взаємодіють між собою.

- **Будівельник:** якщо процес створення об'єкта є складним і має багато варіацій.

- **Прототип:** коли необхідно швидко генерувати багато схожих об'єктів.

- **Одинак:** якщо потрібен єдиний глобальний об'єкт у програмі.

**Опис коду у файлі main.py:**
[Посилання на реалізацію](main.py)

У даному коді реалізовано патерн "Будівельник" (Builder) для створення різних конфігурацій комп'ютерів.

**Структура коду:**
- Клас `Computer` - продукт, який ми створюємо
- Клас `ComputerBuilder` - базовий клас будівельника
- Класи `GamingComputerBuilder` та `OfficeComputerBuilder` - конкретні будівельники
- Клас `ComputerAssembler` - директор, який керує процесом побудови

**Переваги цього підходу:**
- Дозволяє створювати складні об'єкти покроково
- Один і той же код будівництва може створювати різні представлення об'єктів
- Ізолює складну логіку створення об'єкта від його бізнес-логіки
- Дає більше контролю над процесом створення об'єкта

**Недоліки цього підходу:**
- Потребує створення додаткових класів, що може ускладнити код
- Клієнт повинен знати про конкретні класи будівельників
- Може бути надмірним для простих об'єктів

```mermaid
classDiagram
    class Computer {
        +parts: dict
        +add_part(key, value)
        +show_specs()
    }
    
    class ComputerBuilder {
        +computer: Computer
        +get_computer()
        +build_processor()
        +build_memory()
        +build_storage()
    }
    
    class GamingComputerBuilder {
        +build_processor()
        +build_memory()
        +build_storage()
    }
    
    class OfficeComputerBuilder {
        +build_processor()
        +build_memory()
        +build_storage()
    }
    
    class ComputerAssembler {
        -builder: ComputerBuilder
        +construct_computer()
    }
    
    ComputerBuilder <|-- GamingComputerBuilder
    ComputerBuilder <|-- OfficeComputerBuilder
    ComputerBuilder --> Computer
    ComputerAssembler --> ComputerBuilder
```

### Висновок 

На цій лабораторній роботі я ознайомився з принципами роботи твірних патернів проектування, зокрема з патерном Будівельник (Builder). Я навчився створювати складні об'єкти крок за кроком, використовуючи один і той самий код побудови для отримання різних представлень об'єкта. Цей патерн дозволяє краще організувати код при створенні складних об'єктів та робить його більш гнучким і підтримуваним.